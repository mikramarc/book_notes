# Effectiver C++

## Item 1: View C++ as a federation of languages
- C
- O-O C++
- Template C++
- STL

**TLDR:**

**Rules for effective programming in C++ depend on the part of C++ used.**

## Item 1: consts, enums, inlines > defines

- "Prefer the compiler to the preprocessor"
- name gets "removed" by preprocessor before it gets to the compiler -> hard to track down
- replace with constants
- smaller code - pre-processor bind substitution could result in multiple copies of a value
- constants for class - make it a member, to ensure one copy - make it static
- macros don't respect scope
- be aware of the "enum hack"

**TLDR:**
- **Prefer const or enums over defines**
- **For function-like macros prefer inline functions over defines**

## Item 3: Use const whenever possible

- sometimes it makes sense to return const value (e.g. operator overload)
- bitwise constness: method is const if it doesn't modify any of the object's data
- logical constness: method might modify some bits in the object, but only in ways that clients cannot detect
- use `mutable` to ensure logical constness if bitwise constness is broken
- avoid duplicating const and non-const methods, call const within non-const using casting instead

**TLDR:**
- **Declaring const helps the compiler detect usage errors**
- **const can be applied to objects of any scope, function params, return types, methods**
- **Compiler enforces bitwise constness, but you should program using logical constness**
- **Avoid code duplication by having non-const method version call the const version**

## Item 4: Initialize object before usage

- For non-member object of build-it types - manually initialize
- For almost everything else - constructor responsible for initialization everything in the object
- assignment is not initialization
- data members should be initialized before constructor body entered - use initialization list
- using initialization list more efficient than assignment
- use initialization list even when you want to default-construct a data member, specify nothing as an argument (might be an overkill)
- easiest to just *always* use initialization list
- could maybe omit initialization list if multiple constructors - use pseudo-initialization via assignment in shared method
- initialization order: base classes before derived, data members in order they are declared
- static objects - destroyed when the program exits (main finishes executing)
- translation unit - source file + it's include fies (source code giving rite to a single object file)
- local static objects are initialized when object's definition is first encountered during a call to that function
- non-const static objects = problem for multithreading

**TLDR:**
- **Manuall initialize objects of build-in type**
- **In a constructor, prefer use of initialization list**
- **list data in initialization list in the same order as declated in the class**
- **Replace non-local static objects with local static objects to prevent initialization order issues accross translation units**

## Item 5: Know what functions C++ silently writes (and calls)

 - if not explicitly declared, compiler will declare: copy constructor, copy assignment operator, desctructor
 - if no constructor declared - also a default constructor
 - all autogenerated will be public and inline
 - C++ doesn;t provide a way to make a reference refer to a different object

 **TLDR:**
 **Compiler may explicitly generate: default constructor, copy constructor, copy assignment operator, destructor.**

## Item 6: Disallow the use of compiler-generated functions you don't want

- you could forbid a copy of an object if e.g. you want each copy to be unique
- prevent autogeneration by declaring
- prevent usage by making private
- prevent usage by friends and members by NOT defining (link-time error)
- examples found in iostream, e.g. ios_base, basic_ios
- common convention - omit parameter names
- can move link-time error to compile time by making a uncopyable class and inherit from it
- there is an uncopyable version available in Boost (noncopyable)

**TLDR:**
**TO disallow methods autogeneration by compiler, declare the corresponding methods private and give them no implementations.**

## Item 7: Declare destructors virtual in polymorhic base classes

- relecant with base class pointers used
- factory function - returns a base class pointer to a newly-created derived class object
- problem - pointer to a derived class returned, deleted by a base class pointer, base class has a non-virtual destructor
- C++ specifies: if a derived class object deleted through a pointer to a base class without a virtual destructor -> undefined behaviour
- typically at runtime the derived part is never destroyed
- base part destroyed -> leaves a weird, partially destroyed object
- fix: give the base class a virtual destructor
- each class with virtual methods should almost certainly have a virtual destructor
- if no virtual methods = usually indicates the class not intended to be a base class -> virtual destructor usually a bad idea then
- if virtual methods - class carries a virtual table pointer (vptr) which points to virtual table (vtbl, array of funtion pointers).
- vptr will increase objects size, so don't add if not necessary
- STL container classes LACK virtual destructor - do NOT derive
- if you want a class without any pure virtual functions to be abstract - create a pure virtual destructor (need to provide a definition though)
- polymorphic base blass = base class designed to allow the manipulation of derived class types through base class interfaces
- virtual desctructors -> applies only to polymorphic base classes
- simplified version: declare virtual destructor if a class has a virtual method

**TLDR:**
- **Polymorphic base classes should declare a virtual destructor. A class has any virtual method -> it should have a virtual destructor**
- **Classes not desiged to be base or polymorphic should not have virtual desctructors**

## Item 8: Prevent destructors from emitting exceptions
- depending on a condition, multiple simultaneously active exceptions cause either program termination or undefined behaviour
- if need to run something in destructor that could throw exception, you can do two things: terminate the program (catch and sth::abort()) or swollow the exception (empty catch(), or make log entry in a catch())
- calling abort may forestall undefined behaviour, reasonable option if the program cannot continue to run after the error
- in general swallowing exception is a bad idea - it supressed important information, sometimes though it can prevent premature termination and undefined behaviour
- swallowing exception a viable option only if the program is able to reliable continue execution after an error occurs and is ignored
- better strategy - design the class interface so that its clients have an opportunity to react to problems that may arise, e.g. wrap a method that could throw exception in additional method with a flag inside
- if some operation may fail with exception and there may be a need to handle that exception -> the exception has to come from a non-destructor funtion

**TLDR:**
- **Destructors should NEVER emit exceptions. If function called in destructor may throw, catch and terminate or swallow**
- **If clients need to be able to react to exception, class should provide a regular (not a destructor) method that performs operation in question**

## Item 9: Never call virtual methods during construction and destruction

- Base class parts of derived class objects always constructed before derived class parts
- during base class construction virtual functions never go down into derived classes
- during base class construction of a derived class object, the type of the object IS that of the base class, and is treated like that
- one way to avoiding call of virtual function in constructor is making a function non-virtual with parameters and pass args from derived class constructors
- make the method above static - then no danger of accidentally using yet-uninitialized data members

**TLDR:**
**Never call virtual methods during construction and destruction - such call will never go to a more derived class than that of the currently executing constructor or destructor**

## Item 10: Have assignment operators always return a reference to *this

- assignment is right-associative (x = y = z = 15 <=> x = (y = (z = 15)))
- Follow this convention with custom assignment operators using return *this
- Applies also to +=, -=, *= etc.
- it's only a convention but followed by all the built-in types, STD types, etc.

**TLDR:**
**Make assignment operators return a reference to \*this**

## Item 11: Handle assignment to self in operator=

- aliasing = more than one way to refer to an object
- identity test - (`if(this == &rhs) return *this`)
- avoid having pointers to deleted objects
- making operator= exception-safe usually also self-assignment-safe
- ordering of statements (like deleting a pointer only after it's been used) can assure that
- alternative techinque for exception-safety - "copy and swap"

**TLDR:**
- **Use techniques like coparing addresses, careful statement ordering and copy-and-swap to assure operator= is well behaved**
- **Make sure that any funtion that operates on more than one object behaves correctly if two or more objects are the same**

## Item 12: Copy all parts of an object

- In a well-design system only two functions copy object - copy constructor and copy assignment operator (copying functions)
- Most compilers won't complain about if not all of data is copied by copying functions
- if you add a data member to your class, you need to make sure to update copying functions (also constructors)
- issues especially prone to happen with inheritance
- fix issues with inheritance by copying the base class parts - typically private so invoke corresponding base class copying funtioncs
- don't call one copying function in another
- use shared `init()` function to avoid code duplication is similar code in copy constructor and copy assignment operator

**TLDR:**
- **Copying functions should copy ALL of object's data members and ALL of its base class parts**
- **Don't call one of copying functions from another. Put common functionality in a third function and use it in both**

## Item 13: Use objects to manage resources

- Other than memory, some other resource examples are: file descriptors, mutex locks, fonts and brushes in GUIs, database connections, network sockets
- "Manual" resource management is error-prone as code changes over time (people adding breaks, returns, exception throws etc.)
- automatically control resource management by putting resource inside objects
- smart pointers (like std::auto_ptr) automatically release memory in their destructors
- two critical aspects of using objects to manage resources: a) resources are aquired and immedaitely passed to resource-managing objects, b) resource-managing objects use destructors to ensure resource release
- using objects to manage resources ofter called RAII (Resource Acquisition Is Initialization) - common practice to acquire a resource and initialize a resource-managing object in the same statement
- sometimes acquired resources assigned to objects instead of initializing them
- example of RAII - `std::auto_ptr<SomeObject> pso(returnPtrToSomeObject())`
- reference-counting smart pointer (RCSP), e.g. shared_ptr - keeps track of how many objects point to particular resource
- RCSPs can't break cycles of references (two otherwise unused objects pointing to one another)
- don't use shared_ptr or auto_ptr for dynamically aloccated arrays in C++ (they use `delete` instead of `delete[]`). If you need this, look to Boost
(scoped_array, shared_array)
- bottom line - if you're releasing memory manually, you're doing something wrong
- returning of a raw pointer type - bad idea, invitation to a resource leak

**TLDR:**
- **To prevent resource leaks, use RAII objects that acquire resources in their constructors and release them in the destructors**
- **There are some commonly used RAII classes like std::shared_ptr, std::unique_ptr, etc.**
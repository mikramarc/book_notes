# Effective C++

## Accustoming yourself to C++

### Item 1: View C++ as a federation of languages
- C
- O-O C++
- Template C++
- STL

**TLDR: Rules for effective programming in C++ depend on the part of C++ used.**

### Item 2: consts, enums, inlines > defines

- "Prefer the compiler to the preprocessor"
- name gets "removed" by preprocessor before it gets to the compiler -> hard to track down
- replace with constants
- smaller code - pre-processor bind substitution could result in multiple copies of a value
- constants for class - make it a member, to ensure one copy - make it static
- macros don't respect scope
- be aware of the "enum hack"

**TLDR:**
- **Prefer const or enums over defines**
- **For function-like macros prefer inline functions over defines**

### Item 3: Use const whenever possible

- sometimes it makes sense to return const value (e.g. operator overload)
- bitwise constness: method is const if it doesn't modify any of the object's data
- logical constness: method might modify some bits in the object, but only in ways that clients cannot detect
- use `mutable` to ensure logical constness if bitwise constness is broken
- avoid duplicating const and non-const methods, call const within non-const using casting instead

**TLDR:**
- **Declaring const helps the compiler detect usage errors**
- **const can be applied to objects of any scope, function params, return types, methods**
- **Compiler enforces bitwise constness, but you should program using logical constness**
- **Avoid code duplication by having non-const method version call the const version**

### Item 4: Initialize object before usage

- For non-member object of build-it types - manually initialize
- For almost everything else - constructor responsible for initialization everything in the object
- assignment is not initialization
- data members should be initialized before constructor body entered - use initialization list
- using initialization list more efficient than assignment
- use initialization list even when you want to default-construct a data member, specify nothing as an argument (might be an overkill)
- easiest to just *always* use initialization list
- could maybe omit initialization list if multiple constructors - use pseudo-initialization via assignment in shared method
- initialization order: base classes before derived, data members in order they are declared
- static objects - destroyed when the program exits (main finishes executing)
- translation unit - source file + it's include fies (source code giving rite to a single object file)
- local static objects are initialized when object's definition is first encountered during a call to that function
- non-const static objects = problem for multithreading

**TLDR:**
- **Manuall initialize objects of build-in type**
- **In a constructor, prefer use of initialization list**
- **list data in initialization list in the same order as declated in the class**
- **Replace non-local static objects with local static objects to prevent initialization order issues accross translation units**

****

## Constructors, Destructors, Assignment Operators

### Item 5: Know what functions C++ silently writes (and calls)

- if not explicitly declared, compiler will declare: copy constructor, copy assignment operator, desctructor
- if no constructor declared - also a default constructor
- all autogenerated will be public and inline
- C++ doesn;t provide a way to make a reference refer to a different object

**TLDR: Compiler may explicitly generate: default constructor, copy constructor, copy assignment operator, destructor.**

### Item 6: Disallow the use of compiler-generated functions you don't want

- you could forbid a copy of an object if e.g. you want each copy to be unique
- prevent autogeneration by declaring
- prevent usage by making private
- prevent usage by friends and members by NOT defining (link-time error)
- examples found in iostream, e.g. ios_base, basic_ios
- common convention - omit parameter names
- can move link-time error to compile time by making a uncopyable class and inherit from it
- there is an uncopyable version available in Boost (noncopyable)

**TLDR: to disallow methods autogeneration by compiler, declare the corresponding methods private and give them no implementations.**

### Item 7: Declare destructors virtual in polymorhic base classes

- relecant with base class pointers used
- factory function - returns a base class pointer to a newly-created derived class object
- problem - pointer to a derived class returned, deleted by a base class pointer, base class has a non-virtual destructor
- C++ specifies: if a derived class object deleted through a pointer to a base class without a virtual destructor -> undefined behaviour
- typically at runtime the derived part is never destroyed
- base part destroyed -> leaves a weird, partially destroyed object
- fix: give the base class a virtual destructor
- each class with virtual methods should almost certainly have a virtual destructor
- if no virtual methods = usually indicates the class not intended to be a base class -> virtual destructor usually a bad idea then
- if virtual methods - class carries a virtual table pointer (vptr) which points to virtual table (vtbl, array of funtion pointers).
- vptr will increase objects size, so don't add if not necessary
- STL container classes LACK virtual destructor - do NOT derive
- if you want a class without any pure virtual functions to be abstract - create a pure virtual destructor (need to provide a definition though)
- polymorphic base blass = base class designed to allow the manipulation of derived class types through base class interfaces
- virtual desctructors -> applies only to polymorphic base classes
- simplified version: declare virtual destructor if a class has a virtual method

**TLDR:**
- **Polymorphic base classes should declare a virtual destructor. A class has any virtual method -> it should have a virtual destructor**
- **Classes not desiged to be base or polymorphic should not have virtual desctructors**

### Item 8: Prevent destructors from emitting exceptions
- depending on a condition, multiple simultaneously active exceptions cause either program termination or undefined behaviour
- if need to run something in destructor that could throw exception, you can do two things: terminate the program (catch and sth::abort()) or swollow the exception (empty catch(), or make log entry in a catch())
- calling abort may forestall undefined behaviour, reasonable option if the program cannot continue to run after the error
- in general swallowing exception is a bad idea - it supressed important information, sometimes though it can prevent premature termination and undefined behaviour
- swallowing exception a viable option only if the program is able to reliable continue execution after an error occurs and is ignored
- better strategy - design the class interface so that its clients have an opportunity to react to problems that may arise, e.g. wrap a method that could throw exception in additional method with a flag inside
- if some operation may fail with exception and there may be a need to handle that exception -> the exception has to come from a non-destructor funtion

**TLDR:**
- **Destructors should NEVER emit exceptions. If function called in destructor may throw, catch and terminate or swallow**
- **If clients need to be able to react to exception, class should provide a regular (not a destructor) method that performs operation in question**

### Item 9: Never call virtual methods during construction and destruction

- Base class parts of derived class objects always constructed before derived class parts
- during base class construction virtual functions never go down into derived classes
- during base class construction of a derived class object, the type of the object IS that of the base class, and is treated like that
- one way to avoiding call of virtual function in constructor is making a function non-virtual with parameters and pass args from derived class constructors
- make the method above static - then no danger of accidentally using yet-uninitialized data members

**TLDR:**
**Never call virtual methods during construction and destruction - such call will never go to a more derived class than that of the currently executing constructor or destructor**

### Item 10: Have assignment operators always return a reference to *this

- assignment is right-associative (x = y = z = 15 <=> x = (y = (z = 15)))
- Follow this convention with custom assignment operators using return *this
- Applies also to +=, -=, *= etc.
- it's only a convention but followed by all the built-in types, STD types, etc.

**TLDR:**
**Make assignment operators return a reference to \*this**

### Item 11: Handle assignment to self in operator=

- aliasing = more than one way to refer to an object
- identity test - (`if(this == &rhs) return *this`)
- avoid having pointers to deleted objects
- making operator= exception-safe usually also self-assignment-safe
- ordering of statements (like deleting a pointer only after it's been used) can assure that
- alternative techinque for exception-safety - "copy and swap"

**TLDR:**
- **Use techniques like coparing addresses, careful statement ordering and copy-and-swap to assure operator= is well behaved**
- **Make sure that any funtion that operates on more than one object behaves correctly if two or more objects are the same**

### Item 12: Copy all parts of an object

- In a well-design system only two functions copy object - copy constructor and copy assignment operator (copying functions)
- Most compilers won't complain about if not all of data is copied by copying functions
- if you add a data member to your class, you need to make sure to update copying functions (also constructors)
- issues especially prone to happen with inheritance
- fix issues with inheritance by copying the base class parts - typically private so invoke corresponding base class copying funtioncs
- don't call one copying function in another
- use shared `init()` function to avoid code duplication is similar code in copy constructor and copy assignment operator

**TLDR:**
- **Copying functions should copy ALL of object's data members and ALL of its base class parts**
- **Don't call one of copying functions from another. Put common functionality in a third function and use it in both**

****

## Resource Management

### Item 13: Use objects to manage resources

- Other than memory, some other resource examples are: file descriptors, mutex locks, fonts and brushes in GUIs, database connections, network sockets
- "Manual" resource management is error-prone as code changes over time (people adding breaks, returns, exception throws etc.)
- automatically control resource management by putting resource inside objects
- smart pointers (like std::auto_ptr) automatically release memory in their destructors
- two critical aspects of using objects to manage resources: a) resources are aquired and immedaitely passed to resource-managing objects, b) resource-managing objects use destructors to ensure resource release
- using objects to manage resources ofter called RAII (Resource Acquisition Is Initialization) - common practice to acquire a resource and initialize a resource-managing object in the same statement
- sometimes acquired resources assigned to objects instead of initializing them
- example of RAII - `std::auto_ptr<SomeObject> pso(returnPtrToSomeObject())`
- reference-counting smart pointer (RCSP), e.g. shared_ptr - keeps track of how many objects point to particular resource
- RCSPs can't break cycles of references (two otherwise unused objects pointing to one another)
- don't use shared_ptr or auto_ptr for dynamically aloccated arrays in C++ (they use `delete` instead of `delete[]`). If you need this, look to Boost
(scoped_array, shared_array)
- bottom line - if you're releasing memory manually, you're doing something wrong
- returning of a raw pointer type - bad idea, invitation to a resource leak

**TLDR:**
- **To prevent resource leaks, use RAII objects that acquire resources in their constructors and release them in the destructors**
- **There are some commonly used RAII classes like std::shared_ptr, std::unique_ptr, etc.**

### Item 14: Carefully think about copying behavior in resource-managing classes

- another example of resource to be managed is locking and unlocking mutexes
- if RAII object copied, you should choose one of the following: prohibit copying (declare copying operations private), reference-count to underlying resource (you can use shared_ptr for that), copy the underlying resource (deep copy - should copy both object and the resource it wraps), transfer ownership of the underlying resource (e.g. auto_ptr)
- shared_ptr allows specification of a "deleter" - a function or function object to be called when the reference count goes to zero

**TLDR:**
- **Copying of RAII object means also copying managed resource, so copying behavior of the resources should determin the copying behavior of the RAII object**
- **Common copying behaviors - forbid copying, reference count, deep copy and ownership transfer**

### Item 15: Provide access to raw resources in resource-manging classes

 - sometimes APIs refer to resources (raw data) directly
 - you need to convert RAII object, two general ways: explicit conversion and explicit conversion
 - explicit conversion -> return (a copy of) raw pointer (e.g. inside a smart pointer), e.g. with a get() method for shared_ptr
 - explicit conversion - allow access to underlying data (e.g. by overloading and using -> and * operators)
- an alternative to explicit conversion using get() - implicit conversion function (`operator T() const { return val; }`)
- downside of implicit conversions - increased chance of error, e.g. when using copy assignment operator
- often explicit conversion is preferable -> minimizes chance of unintended conversions, not always the case - design decision
- functions returning raw resources in RAII classes aren't contrary to encapsulation - those classes' purpuse is to handle resrouces, not encapsulate

**TLDR:**
- **Each RAII class sould offer a way to access resource it manages - API's often require access to raw resouces**
- **Access may be through explicit or implicit conversion. In general, explicit conversions are safer, while implicit conversions more convenient to use**

### Item 16: Use same form in corresponding used of new and delete

- when you call `new`, two things happen - memory is allocated and one or more constructors for that memory are called
- when you call `delete` also two things happen - one or more destructors are called, then the memory is released
- memory for an array usually includes size of the array - ease for delete to know how many destructors to call
- if you delete on a pointer, you need to specify whether it's an array or not
- using incorrect `delete` leads to undefined behavior
- to avoid confusion regarding destruction, avoid typedeft for array types

**TLDR: If you use [] in a new expression, you must use [] in a corresponding delete expression, and vice versa.**

### Item 17: Store new-ed objects in smart pointers in standalone statements

- it's possible to leak resources even when using only RAII objects
- e.g. compiler can decide in what order arguments passed to a funtion are processed
- e.g. in a function call if arguments passed are function calls, one of them might throw exception while in another arg you're passing `new` to a smart pointer (`some_function(std::shared_ptr<someObj>(new someObj), other_function())`)
- to avoid that use a separate statement to pass resource to a RAII object, only then pass it - less leeway in reordering operations for the compiler

**TLDR: Store new objects in smart pointer in standalone statements**

****

## Designs and Declarations

### Item 18: Make interfaces easy to use correctly and difficult to use incorectly

 - if the client attempts to use interface incorrectly, it should not compile
 - can use structs/classes instead of basic types to enforce correct argument passing (e.g. `Hour(const Minute& m, const Hour& h)` instead of `Hour(int minute, int hour)`)
 - you can use static methods returning call to private constructor in a class to enforce specific values set (e.g. `static Month Jan() {return Month(1);}`)
 - you can also impose restrictions adding `const` (e.g. returning a const value from assignment operator)
 - interfaces should behave consistently
 - interface that requires client to remember something is prone to incorrect use
 - you can use a deleter in shared pointer to enforce specific behavior upon deleting
 - "cross-DLL problem" - object created by `new` in one DLL deleted in another DLL
 - shared pointer is biggerr than raw pointer, slower than raw pointer and uses auxiliary dynamic memory - but reduces client errors

**TLDR:**
- **Good interface = easy to use correctly, hard to use incorrectly**
- **Facilitate correct use with consistency in interfaces and behavioral compatibility with build-in types**
- **Ways to prevent errors include: creating new types, restricting operations on types, constraining object values, eliminating client resource management responsibilities**
- **shared_ptr supports custom deleters - prevents cross-DLL problem or can be used to automatically unlock mutexes**

### Item 19: Treat class design as type design

Consider:
- how should objects of your type be created/destroyed?
- how should object initialization differ from assignment?
- what does it mean for object to be passed by value?
- what are restrictions on allowed values for you class?
- does your new type fit into an inheritance graph?
- what kind of type conversions are allowed for you new class?
- what operators and functions make sense for the new type?
- what standard functions should be disallowed?
- who should have access to the members?
- what guarantees you new class offer with respect to performace, exception safety and resource usage ("undeclared interface")?
- how general is you new type?
- do you really need a new type?

**TLDR: Class design = type design**

### Item 20: Prefer pass-by-const-reference to pass-by-value

- when you pass by value you call all the copy constructors (original object, parent object, class member objects)
- same goes for destructors
- passing by const-reference is much more efficient
- avoids "slicing" problem - when a derived class object is passed (by value) as a base class object, the base class copy constructor is called -> specialized features that make the object behave like a derived class object are "sliced off"
- references are typically implemented as pointers, so passing by reference usually really means passing by pointer
- for built-ins usually more efficient to pass by value
- small class -> doesn't mean copying is cheap, they could point to a very large object
- compilers tend to treat used defined classes and built-in types differently, even when same underlying representation
- user-defined types not good candidates to be passed by value - they are subject to change

**TLDR:**
- **Prefer pass-by-const-reference over pass-by-value - typically more efficient and avoids slicing problem**
- **Passing by value ok for built-in types, STL iterator and function object types**

### Item 21: Dn't try to return a reference when you're supposed to return an object

- do not pass reference to the object that does not exist
- reference is just a name of some (already existing) object
- two ways of creating new object by function - on the stack or on the heap
- creation on the stack - local variables
- don't return reference to a local object it will be immediately destroyed when funtion goes out of scope -> results in undefined behavior
- any function returning reference to a local object is broken, some for pointer to a local object
- creation on the heap - using `new`
- static objects - could affect thread-safety
- do not use static objects defined inside a function to try to return const reference
- the right way to write a funtion that must return a new object -> have that funtion return a new object
- between returning a value and returning a reference, choose what renders correct behavior, let the compiler worry about optimization

**TLDR: Never return a reference or a pointer to a local stack object, a reference to heap-allocated object or a reference or a pointer to a local static object (if there is a chance that more than one such object will be needed)**

### Item 22: Declare data members private
- reasons to not have public data members: syntactic consistency (you just use functions to access objects), using functions gives more control over accessibility, encapsulation (if you use funtion to retrive a data member, you can replace that member later with a computation, etc. and clients won't know)
- other reasons to hide data members behind functional interfaces: option to notify other objects when data is written or read, to verify class invariants and function pre/post-conditions, performing synchronization in threaded environments, etc.
- public = unencapsulated = effectively unchangable
- same goes for protected data - changes in the unencapsulated data might break all the derived classes

**TLDR:**
- **Declare data members private - gives syntactucally uniform access, allows fine-grained access control, allows invariants to be enforced, and offers class authors implementation flexibility**
- **protected is effectively no more encapsulated than public**

### Item 23: Prefer non-member non-friend functions to member functions

- encapsulation - allows flexibility to change things in a way that affects only limited number of clients
- the less code (functions) can access data, the more data is encapsulated
- non-member non-friend functions don't decrease encapsulation since they don't increase number of functions that can access private data
- just because encapsulation-related concers dictate a function be a a non-member non-friend of one class, it doesn't mean it cannot be a member of another class
- natural approach - make function a non-member non-friend function in the same namespace as the original class
- good approach with "convenience functions"
- namespaces, unlike classes, can be spread across multiple source files
- declare specific-stuff-related convenience functions in different header files - exactly how C++ standard library is organized
- spreading across multiple source files allows clients to not be compilation-dependent on stuff they don't need
- partitioning functionality like this is not possible with class member functions - class can't be split into pieces between files
- putting convenience funtions in multiple header files (but same namespace) also allows for easy extension of the set of convenience functions - another feature classes don't offer

**TLDR: Prefer non-member non-friend functions over member functions - it increases encapsulation, packing flexibility, and functional extensibility.**

### Item 24: Declare non-member functions when type conversions should apply to all parameters

- having class support implicit conversions - generally a bad idea (not always though)
- compilers can do implicit conversions if the constructor allows it (non-explicit constructor)
- parameters are eligible for implicit type conversion *only if listed in the parameter list*. 
- whenever you can avoid friend functions, you should

**TOLD: If you need type conversions on all function's parameters (including the one that would otherwise be pointed to by the *this* pointer), the function must be a non-member**

### Item 25: Consider support for a non-throwing swap

- swap is very useful, so important to implement it properly
- swap two items = give each the other's value
- as long as your types support copying, the default std swap will let your objects be swapped without issues
- default swap performs thee copying operations - could be slow
- primarily a problem for classes pointing to another class with implementation ("pimpl idiom")
- `template <>` = total template specialization (specialization for specific type)
- we're not allowed to alter contents of std, but we are allowed to totally specialize standard templates for our own types
- to alter std::swap make a public swap funtion and use it within std::swap
- C++ allows partial specialization of class templates, but not function templates
- when you want to partially specialize a function, typically you overload it - not possible for std, though - altering contents prohibited
- way to do this - make a swap in your namespace and due to name lookup rules in C++ (argument-dependant lookup / Koenig lookup) it will be found
- for classes do both non-member swap in you class's namespace and the specialization
- desirable is to use T-specific version if there is one, but to fall back to std one it there isn't one - you can force that using `using std::swap`
- calling `std::swap(...)` forces compiler to use std version
- member version of swap should never throw exceptions (applies only to the member version)

**TLDR:**
- **Provide a swap member function when std::swap inefficient for your type and make sure it doesn't throw exceptions**
- **if you offer a member swap, also offer a non-member swap that calls the member. For classes (but not templates) specialize std::swap as well**
- **when calling swap, employ a using declaration for std::swap and call swap without namespace qualification**
- **it's ok to totally specialize std templates for user-defined types, but never try to add anything completely new to std**

****

## Implementations

### Item 26: Postpone variable definitions as long as possible

- avoid unused variables whenver you can, e.g. when an exception is thrown
- postpone variable definition until you are sure you will need it
- avoid (potentially expensive) default construction if possible
- postpone variable definition until right before you use it, but also until you have initialization arguments for it - you avoid potentially unnecessary construction/destruction, and unnecessary default construction
- when it comes to loops it depends whether construction/destruction or copy assignment is cheaper
- also, defining outside of the loop make larger scope - usually contrary to program comprehensability and maintainability - so unless assignment is cheaper than construction-destruction and you have a performance sensitive code, construct-destruct within the loop

**TLDR: Postpone variable definitions as long as you can - it increases program clarity and improves efficiency**

### Item 27: Minimize casting

- old style casts (C style) - `(T) expression` or `T(expression)`
- new style casts: `const_cast<T>`, `dynamic_cast<T>`, `reinterpret_cast<T>` and `static_cast<T>`
- `const_cast` - casts away constness of objects. Only cast that does that.
- `dynamic_cast` - primarily used to perform "safe downcasting", i.e. determining whether an object is of a particular type in an inheritance hierarchy. Only cast that cannot be done using old style cast, it can aplso have significant runtime cost
- `reinterpret_cast<T>` - low-level casts yielding implementation-dependant results, e.g. casting a pointer to an int. Should be rare outside low-level code
- `static_cast<T>` - can be used to force implicit conversions (e.g. non-const object to const object, int to double, etc.). Also reverse, e.g. void* pointer to typed pointer, base-pointer to derived pointer, etc. Cannot do const to non-const, though.
- old style casts still legal but new ones preferable - easier to identify, more narrowly specified purpose
- type conversions often lead to code executed at runtime
- single object might have more than one address (e.g. its address when pointed to by Base* and address when pointed by Derived*). With multiple inheritance virtually all the time, with single, sometimes too.
- often if you find youself wanting to cast, it's a sign that you could be approaching things the wrong way - especially the case for dynamic_cast.
- many implementations of dynamic_cast are quite slow, e.g. based on class names string comparison
- dynamic_cast generally used when yuo want to perform derived class operations on (what you believe) to be a derived class object but you only have a pointer- or reference-to-base available
- you should always avoid cascading dynamic_casts (e.g. if - else - else - ... with different dynamic_casts) - generates code that is big and slow

**TLDR:**
- **Avoid casts whenever practical, especially dynamic_casts in performcance-sensitive code. If casting required in a design, try to come up with a cast-free alternative**
- **when casting necessary, try to hide it inside a function so clients can avoid casts in their own code**
- **prefer C++ style casts to old style casts - easier to see and more specic about what they do**

### Item 28: Avoid returning "handles" to object internals

- Data member is only as encapsulated as the most accessible function returning a reference to it
- even if a member funtion is const but returns a reference to data associated with an object that is stored outside the object itself, the caller to the function can modify the date
- same issues with pointers and iterators
- also, you should not have a member funtion return a pointer to a less accessible member function
- instead, return const reference instead of just reference
- still can lead to problems, like "dangling handles" - handles that refer to parts of objects that don't exist anymore, e.g. pointer points to return value that is local scope only and will get destroyed soon
- returning handles to internal parts of an object is always dangerous
- doesn't mean you should never do it - sometimes you have to

**TLDR: Avoid returning handles (references, pointers or iterators) to object internals when possible. Not returning handles increases encapsulation, helps const member functions be const and minimizes the risk of creation of dangling handles**

### Item 29: Strive for exception-safe code

- 2 requirements for exception safety: leak no resources and don't allow data structures to become corrupted
- resource management classes can make functions shorter
- exception safe functions offer one of three guarantees: a) basic guarantee - if an exception is thrown, everything in the program remains in a valid state (no objects or data structures become corrupted etc.), b) strong guarantee - if an exception is thrown, the state of the program is unchanged, c) nothrow guarantee -  functions promise to never throw exceptions
- exception-safe code must offer on of the three guaranetees above
- your code should always be exception-safe (accept maybe when dealing with exception-unsafe legacy code)
- as a general rule, you want to offer the strongest guarantee that's practical - offer nothrow if you can but for most functions it will be between basic and strong guarantees
- general design strategy that typically leads to the strong guarantee - "copy and swap"
- "copy and swap" in principle: make a copy of the object you want to modify, then make all needed chages on that copy
- "pimpl idiom" - putting all the per-object data from the "real" object into a separate implementation object, then giving the real object a pointer to its implementation object
- copy-and-swap doesn't always guarantee that the overall function is strongly exception-safe, e.g. there might be other functions within that could change the guarantee, e.g. they don't operate only on the local state (side-effects)
- another problem with copy-and-swap is efficiency - copying can be costly
- strong guarantee always desirable, but not always practical
- if strong-guarantee not practical, offer basic guarantee
- when writting new code or modifying existing one, think about how to make it exceptin-safe - use objects to manage resources, determine which three exception safety guarantees is the strongest you can practically offer, settle for no guarantee onfly if legacy code leaves you no choice, document your decisions

**TLDR**
- **Exception-safe functions leak no resources and allow no data structures to become corrupted, even when exceptions are thrown. Such functions offer: basic, strong or nothrow guarantees**
- **Strong guarantee can be often implemented via copy-and-swap but it's not practical for all functions**
- **A function can usually offer a guarantee no stronger than the weakest guarantee of the functions it calls**

### Item 30: Understand inlining

- inline function: saves overhead of a funcion call
- inlining may enable compilers to perform context-specific opimizations
- inlining is likely to increase the size of your object code - could be problem with machines with limited memory
- inline-induced bloating can lead to additional paging, reduced instruction cache hit rate and performance penalties that accompany these things
- in inline function very small the code generated may be smaller than the one for function call
- inlining is a request to a compiler, not command
- implicit request - defining a function inside a class definition - usually members but could also be friends
- explicit request - inline keywaord
- inline functions must typically be in header files - most build environments do inlining during compilation
- templates usually in header files - compilers need to know what it looks like in order to instantiate it when it's used
- templating independent from inlinig
- most compilers refuse to inline functions them deem too complicated (e.g. with loops or recursive)
- mostly virtual functions refused - quite obvious
- compilers typically don't perform inlining across calls through function pointers
- constructors/destructors bad candidates for inlining - sometimes compilers can auto-generate code in them
- if f is an inline function in a library, clients of the library compile the body of f into their applications - need for recompilation if f changes; if f non-inline clients only need to relink
- most debuggers have trouble with inline functions
- strategy: initially don't inline anything (apart from functions that must be inline or are truly trivial (e.g. one return))
- 80/20 rule in coding - most programs spend 80% of it's time running 20% of your code

**TLDR:**
- **Limit most inlining to small, frequently called functions. This facilitatess debugging and binary upgradeability, minimizes potential code bloating, and maximizes the chances of greater program speed**
- **Don't declare function templates inline just because they appear in headers**

### Item 31: Minimize compilation dependencies between files

- C++ doesn't do great with separating interfaces from implementations - class definition specifies not only an interface but also some implementation details
- "pimpl idiom" - two classes, one for interface only, one implementing the interface (holding the data)
- pimpl - replacement of dependencies ons definitions with dependencies on declarations
- essence of minimizing compilation dependencies: make your header files self-sufficient whenever it's practical, and when it's not, depend on declarations in other files, not definitions
- desing strategy: a) avoid using objects when object references and pointers will do (you can define reference and pointer to a type with only a declaration for the type, defining object requires presence of type's definition), b) depend on class declarations instead of definitions whenver you can, c) provide separate header files for declarations and definitions
- you *never* need a class definition to declare a function using that class
- Interface class - special kind of abstarct base class specifyin an interface for derived class
- like with Handle classes (pimpl), clients of Interface classes need not recompile unless the Interface class interface is modified
 - you can write create method in interface to create objects enforcing the interfaces
 - two most common mechanisms for implementing an Interface class - inherit interface specification from the Interface class, implement the functions in the interface
 - Handle classes and Interface classes - decouple interfaces from implementations = reduce compilation dependencies between files
 - cost for those methods - some speed at runtime + additional memory per object
 - Handle - member functions go through implementation pointer (adding one level of access indirection), adds the size of implementation pointer to the memory required ro store each object, plus the implementation pointer has to be initialized (dynamically allocated memory)
 - Interfaces - every function call virtual - cost of an indirect jump each time function called, plus objects derived from the Interface class must contain virtual table pointer - more memory needed to store an object
 - neither Handle not Interface classes can get much use our of inline functions

 **TLDR**
 - **General idea behing minimizing compilation deps - depend on declarations instead of definitions. Two approaches based on this idea are Handle and Interface classes**
 - **Library header files should exist in full and declaration-only form**

 ****

 ## Inheritance and Object-Oriented Design

 ### Item 32: Make sure public inheritance models "is-a"

 - class D publicly inherits from class B = every object of type D is also of type B, but not vive versa
 - any function that expects an argument of type B will also take a type D (or pointer-to-D/reference-to-D)
 - only true for public inheritance
 - there is no idea design for ALL software - always context dependant
 - good interfaces prevent invalid code from compiling - better to reject undesired behavior at compile time rather than runtime
 - public inheritance asserts that everything that appliess to base class objects (everything!) also applies to derived class objects

 **TLDR: Public inheritance means "is-a". Everything that applies to base class must also apply to derived class, because every derived class object is a base class object**

 ## Item 33: Avoid hiding inherited names

 - names in inner scopes hide ("shadow") names in outer scopes
 - types don't matter when it comes to hiding
 - scope of derived class nested inside base class's scope
 - compilers search scopes from the most inner to the most outer
 - same way for hiding goes for functions with different argument types
 - override C++'s default hiding of inherited names with "using" declarations (`using Base::func;`)
 - if you inhering from a base class with overloaded functions and you want to redefine or override only some of them, you need to include a "using" declaration for each name you'd otherwise be hiding - otherwise some names will be hidden
 - "using" used in public part - names that are public in base class should be also public in a publicly derived class
 - for private inheritance, use forwarding function (`virtual void f() {Base::f();}`)

 **TLDR:**
 - **Names in derived classes hide names in base classes - under public inheritance never desirable**
 - **To make hidden names visible, use "using" declarations or forwarding functions**

## Item 34: Differentiate between inheritance of interface and inheritance of implementation

- you can want to inherit interface (declaration) of member functions, implementations with option to override, or implementations without option to override
- member function interfaces are always inherited
- pure virtual functions - must be redeclared
- purpose of declaring a pure virtual function is to have derived class inherit a function interface only
- it is possible to provide definition for a pure virtual function - C++ wouldn't complain, but the only way to call it would be to qualify the call with the class name (generaly of limited utility)
- purpose of declaring a simple virtual functions is to have derived class inherit a function interface as well as a default implementation ("You got to support this function, but if you don't want to write your own, fall back to the base class version")
- it can be dangerous to allow simple virtual functions to specify both interface and implementation - risk of forgetting to redifine when needed
 - it's possible to offer defualt behavior to derived class but not unless they ask for it, sever connection between interface and default implementation (make simple virtual into pure virtual and have it call some default protected non-virtual)
 - some people object to this idea (pollutes the class namespace). ANother way is to take advange of possibility to have implementation of pure virtual function (call it with base class name qualifier in derived class function implementations) - issue is that now the implementation is public
 - the purpose of declaring a non-virtual function is to have derived classes inhering a function interface as well as a **mandatory** implementation
 - non-virtual function identifies *invariant* over specialization, should never be redefined in a derived class
 - mistake: make all functions non-virtual - makes no room for specialization in derived classes (unless not intended for being derived)
  - using 80/20 rules - on average 80% of your function calls can be virtual without having detectable impact on performance
  - mistake: declare all member functions virtual - can be right for Interface classes, however some functions should *not* be redefinable and you should state that if necessary (by amking them non-virtual)

  **TLDR:**
  - **inheritance of interface is different from inheritance of implementation - under public inheritance, derived classes always inhering base class interface**
  - **pure virtual functions specify inheritance of interface onlky**
  - **simple virtual functions specify inheritance of interface plus default implementation**
  - **non-wirtual functions specify inheritance of interface plus mandatory implementation**

## Item 35: Consider alternatives to virtual functions

- Alternative 1: Template method pattern via the non-virtual interface idiom
- non-virtual interface idiom (NVI) - having clients call private virtual function indirectly through public non-virtual member function (particular manifestation of Template Method design pattern)
- Having a wrapper ensures that before a virtual function is called, the proper context can be set up and cleaned up (e.g. locking mutex, making a log entry, etc.) - no really a good way to do that if you let clients call virtual function directly
- derived classes may redefine private inhjerited virtual functions = perfectly sensible
- Under NVI idiom, it's not strictly necessary that the virtual functions be private
- Alternative 2: Strategy pattern via Function Pointers
- pass a pointer to function to class constructor
- implementation of a Strategy design pattern
- allows different instances of a class to have different calculation ways for the same thing
- calculation functions can be changed at runtime
- since not longer a member function - no access to class internals, only fix is to weaken encapsulation, e.g. declaring functions as friends or implementing public accessors
- Alternative 3: Strategy patter via tf1::function (currently std::function)
- std:function - general-purpose polymorphic function wrapper, may hold any callable entity whose signature is compatible with what is expected
- instead of holding a pointer to a function like in alternative 2, now we hold a pointer to generalized pointer to a function = clients have more flexibility in specifying/passing functions
- std::bind - partial function application (allows you to set some arguments to static values, e.g. `auto g = bind(f, _1, 4, _2) -> g(a, b) := f(a, 4, b)`)
- Alternative 4: "Classic" strategy pattern: make calculation function a virtual member function of a separate calculation hierarchy
- each object using a function contains a pointer to an object implementing specific version of that function
- Advantage: recognizable as "standard" Strategy pattern, and offers tweak options to the function in question by adding another derived class to class hierarchy

**TLDR:**
- **- non-virtual interface idiom - wrap public non-virtual member function around less accessible virtual functions, example of the Template Method design pattern; use function pointer data members - stripped down manifestation of the Strategy pattern; use std::function data members - allowing use of any callable entitiy with a compatible signature; replace virtual functions in one hierarchy with virtual functions in another hierarchy - conventional Strategy pattern**
- **Disadvantage of moving functionality from a member function to a function outside the class is lack of access to the class's non-public members**
- **std::function object act like generalized function pointers - support all callable entities compatible with a given target signature**

## Item 36: Never redefine an inherited non-virtual function

- non virtual functions are statically bound - if a pointer is of type parent, non-virtual functions invoked through that pointer will always be those defined for parent class, even if the pointer points to an object of child class
- virtual functions are dynamicaly bound - don't suffer from the problem above
- if you redefine a non-virtual function that you inhering from parent class, child class object will likely exhibit inconsistent behavior - would depend on which pointer is used to point to the object (child or parent type)

**TLDR: Never redefine an inherited non-virtual function.**

## Item 37: Never redefine a function's inherited default parameter value

- virtual functions are dynamically bound, but default parameter values are statically bound
- static binding = early binding, dynamic binding = late binding
- static type = type you declare in the program text, dynamic type - determined by the type of the object to which it currently refers
- dynamic types can change as the program runs, typically through assignments
- virtual functions are dynamically bound = the particular function called is determined by the dynamic type of the object through which it's invoked
- bacasue default parameters are statically bound, you may end up invoking a virtual fucntion defined in derived class but using a default parameter value from base class
- reason for allowing this - statically bound parameter values = higher runtime efficiency
- when you're having trouble making virtual function behave as you want, consider alternatives (e.g. from item 35)

**TLDR: Never redefine am inherited default parameter value, since those are statically bound, while virtual functions are dynamically bound**

## Item 38: Model "has-a" or "is-implemented-in-terms-of" through composition

- composition - relationship between types that arises when objects of one type contain objects of another type
- composition synonyms - layering, containment, aggregation, embedding
- composition = "has-a" or "in-implemented-in-terms-of" - depends on if it's application domain (people, vehicles, etc.) or implementation domain (buffers, mutexes, search trees, etc.)
- when composition in application domain - has-a, when in implementation domain - is-implemented-in-terms-of
- is-a = public inheritance, has-a/is-implemented-in-temrs-of = contain objects in class body

**TLDR**
- **Composition has meanings completely different for that of public inheritance**
- **In the application domain, composition means has-a. In the implementation domain, it means is-implemented-in-terms-of**

## Item 39: Use private inheritance judiciously

- for private inheritance, compiler will generally NOT convert a derived class object  into a base class object. Also, members inherited from a private base class become private members of the derived class, even if protected or public in the base class
- private inheritance = is-implemented-in-terms-of
- private inheritance = implementation ONLY should be inherited, interface should be ignored
- use composition whenever you can, and use private inheritance whenever you must
- when must you? Primarily when protected members and/or virtual functions enter the picture (sometimes also space concers)
- instead of using private inheritance you could still use composition - declare a private nested class inside you class that inherits publicly from the class you need, e.g.:

```c++
class Widget {
  private:
    class WidgetTimer: public Timer {
      public:
        virtual void onTick() const;
        ...
    };

    WidgetTImer timer;
    ...
}
```
- this design more complicated that just using private inheritance
- Empty base optimization - with private inheritance of an empty class, size of the new object does not increase
- EBO usually vialble only under single inheritance
- Empty classes - no non-static data members, but can contain typedefs, enums, static data members, or non-virtual functions.
- most classes aren't empty so EBO is rarely a justification for private inheritance
- composition easier to understand - use it whenever possible
- private inheritance - most likely legitimate design strategy when dealing with two classeds not related by is-a, where on needs to access protected members of another, or needs to redefine on or more of its virtual functions

**TLDR:**
- **Private inheritance means is-implemented-in-terms-of. Usually inferior to composition, but makes sens when derived class needs access to protected base class members or needs to redefine inherited virtual functions**
- **Unlike composition, private inheritance can enable empty base optimization - can be important for minimizing objects size**

## Item 40: Use multiple inheritance judiciously

- multiple inheritance makes it possible to inherit the same name from more than one base class -> leads to ambiguity
- C++ first identifies the function that's best match, only than checks for accesibility
- you must resolve ambiguity via "className::"
- "deadly MI diamond" - class inherits from two classes, which both inherit from some class - by default C++ will perform the replication
- if you don't want data replication you need to perform virtual inheritance - make the base class virtual at the inheritance step (`class Child: virtual public Parent {...}`)
- objects created via virtual inheritance are generally larger than normal inheritance because of some behind-the-scenes work dont by the compilers. Access to data members also slower
- another point - rules governing initialization of virtual base classes are more complicated and less intuitive than for non-virtual ones
- advice - don't use virtual base classes unless you absolutely need to; if you must use virtual base clases, try to avoid putting data in them
- composition generally preferred, but inheritance necessary if virtual fucntions are to be redefined
- idea: combine public inheritance of an interface with private inheritance of implementation
- if SI design more or less equivalent to MI design, SI preferable. And there is almost always a way to make SI work

**TLDR:**
- **Multiple inheritance more complex than single inheritance - can lead to new ambiguity issues and to the need for virtual inheritance**
- **Virtual inheritance imposes costs in size, speed, and complexity of initialization and assignment - most practical when virtual base classes have no data**
- **Multiple inheritance does have legitimate uses. One scenario involves combining public inheritance from an Interface class with private inheritance from a class that helps with implementation**

****

 ## Templates and Generic Programming

 ### Item 41: Understanding implicit interfaces and compile-time polymorphism

 - object-oriented programing - explicit interfaces adn runtime polymorphism
 - explicit interface - one explicitly visible in the source code
 - runtime polymorphism - specific function to call determined at runtime based on dynamic type
 - in the templates "world" implicit interfaces and compile-time polymorphism more important
 - implicit interface - set of expressions that must be valid for type T in order for the template to compile
 - compile-time polymorphism  - when calls to functions involving an object involve instantioating templates to make the calls succeed (instantiating function template with different template parameters leads to different functions being called)
 - explicit interface - based on signatures, implicit interface - based on valid expressions
 
 **TLDR:**
 - **Both classes and templates support interfaces and polymorphism**
 - **For classes, interfaces are explicit and centered on function signatures. Polymorphism occurs at runtime through virtual functions**
 - **For template parameters, interfaces are implicit and based on valid expressions. Polymorphism occurs during compilation through template instantiation and function overloading resolution**

 ### Item 42: Understand the two meaning of typename

 - class and typename - no difference

 ```c++
 template<class T> class Widget;
 template<typename T> class Widget;
 ```
 - not always equivalent, though - sometimes you must use typename
 - names in a template dependent on a template parameter are called dependent names (as opposed to non-dependent names)
 - nested dependent name = dependent name nested inside a class
 - if a parser encounters a nested dependent name in a template, it assumes that the name is NOT a type unless you tell it otherwise - nested dependent names are not types by default
 - anytime you refer to a nest4ed dependent type name in a template, you must precede it by the word `typename`

 ```c++
 template<typename C>
 void func(const C& container)
 {
   typename C::const_iterator iter(container.begin());
 }
 ```
 - typename should be used for nested dependent types only
 - exception to the "typename must precede nested dependent type" - a list of base classes or as a base class identifier in a member initialization list
 - enforcing of those rules vary from compiler to compiler

 **TLDR:**
 - **When declaring template parameters, class and typename are interchangeable**
 - **Use typename to identify nested dependent type names, except in a base class lists or as a base class identified in a member initialization list**

 ### Item 43: Know how to access names in templatized base classes

 - wrapping around a inherited function = good design since prevents hiding inherited names and doesn't redefine an inherited non-virtual function
 - with templating, when compiler encounters a definition for a class template, they don't know what class it inherits from (if base class is a templated class)
 - `template<>` syntax at the beginning of the class definition - signifies that it's neither a template nor a standalone class, rather a specialized version of a templated class to be used with specific type (total template specialization)
 - specialized templates may not offer offer the same interface as general templates
 - compilers refuse to look in templatized base classes for inherited names (in a sense, for template c++ inheritance stops working)
 - three ways to fix it: preface calss to base class with `this->`; emply `using` declaration (`using BaseClass<typename_name>::func;`); explicitly specify that function called is in the base class (`BaseClass<typename_name>::func(...);`)
 - third one least desired - of the function called is virtual, explicit qualification turns off the virtaul binding
 - all of the three ways basically promise the compiler that any subsequent specializations of the base class template will support the interface offered by the general template
- compiler can diagnose invaliud references to base class members sooner (when derived class template definitions are parsed) or later (when those templates are instantiated with specific template arguments). C++ prefers early diagnoses

**TLDR: In derived class templates, refer to names in base class templates via `this->` prefix, via `using` declarations, or via an explicit base class qualification.**

### Item 44: Factor parameter-independent code out of templates

- member functions of class templates are implicitly instantiated only when used
- using templates can lead to code bloat: binaries with replicated (or almost replicated) code, data, or both
- the result can be: source code - nice, object code - bleh
- primary tool - commonality and variability analysis
- in non-template code replication explicit - you can see that there's duplication between two functions or classes
- in template source code, replication implicit - only one copy of the template source code, so you have to train yourself to sense the replication that could take place when template instantiated multiple times
- type parameters can lead to code bloat too, e.g. vector<int> amd vector<long>

**TLDR**
- **Templates generate multiple classes and multiple functions, so any template code not dependent on a template parameter causes bloat**
- **Bloat due to non-type template parameters can often be eliminated by replacing template parameters with function parameters or class data members**
- **Bloat due to type parameters can be reduced by sharing implementations for instantiation types with identical binary representations**

### Item 45: Use member function templates to accept "all compatible types"

- raw pointers support implicit conversions well - derived class pointers implicitly convert into base class pointers, pointer to non-const objects convert into pointer to const, etc.
- emulationg such conversions in user-defined smart pointer classes is tricky - needs explicit conversion
- for some cases you need a member function template (or member template) that generate a member functions of a class, e.g.
```c++
template<typename T>
class SmartPtr
{
  public:
    template<typename U>
    SmartPtr(const SmartPtr<U>& other);
}
```
- the above means - for every type T and every type U, a `SmartPtr<T>` can be craeted from a `SmartPtr<U>`. Knows as "generalized copy constructor"
- not explicit for a reason - type conversions among build-in pointer types are implicit and require no cast, so it's reasonable for a smart pointer to emulate that
- member function templates not limited to constructors - another role is support for assignment
- declaring a generalized copy constructor (a member template) in a class doesn't keep compilers from generating their own copy constructor (a non template)

**TLDR:**
- **Use member function templates to generate functions that accept all compatible types**
- **If you declare member templates for generalized copy construction or generalized assignment, you will still need to declate the normal copy constructor and coppy assignment operator**

### Item 46: Define non-member functions inside templates when type conversions are desired

- only non-member functions eligible for implicit type conversions on all arguments
- implicit type conversion functions are never considered during template argument deduction (only during function calls)
- inside class template the name of the template can be used as shorthand for the template and its parameters (inside `ClassName<T>` we can just write `ClassName` instead of `ClassName<T>`)
- solution - declare as friend class inside the class - compilers can use implicit conversion functions when calling a declared function (as opposed to function template). This needs linking fixed, though
- simplest thing to do - merge the body of the function into its declaration
- in this context use of friendship has nothing to do with a need to access non-public parts - we need a non-member function  to make type conversions possible on all arguments, we declare the function inside the class to have the proper function automatically instantiated - the only way to declare a non-member function inside a class = make it a friend
- many compilers force to put all template definitions in header files

**TLDR: When writing a class template that offers functions related to the template that support implicit type conversions on all parameters, define those functions as friends inside the class template.**

### Item 47: Use traits classes for information about types.

- STL contains a few utility templates - one of them is called advance
- advance: moves a specified iterator a specified distance

```c++
template<typename IterT, typename DistT>
void advance(IterT& iter, DistT d);
```
- advance conceptually does just `iter += d` but cant be implemented that way - only random access iterators support the += operation
- five categories of iterators
- "Input iterator" - only forward, one step at a time, only read what they point to, can read what they point to only once
- "Output iterators" - analogous but for the oujtput, instead of reading, it's writing.
- both are least powerful iterators, suitable only for one-pass algorithms
- "forward iterators" - everything input/output iterators plus they can read/write more than once - viable for multipass algorithms
- "bidirectional iterators" add to forward iterators the ability to move backwards as well as forward. Example: set, map, multiset, multimap
- most powerful category - random access iterators - add to bidirectional the ability to perform "iterator arithmetic", i.e. just forward and backward an arbitrary distance in constant time (analogous to opointer arithmetic). Example: iterators for vector, deque or string
- for each of the iterators, c++ has a "tag struct" in the STL to identify it
- traits: allow you to get information about a type during compilation
- traits aren't a keyword or predefined construct in C++ - they are a technique and a convention
- One of the demands - needs to work as well for built-in types as it does for user-defined types
- the traits information for atype must be external to the type
- standard technique - put it into a template and one or more specializations of the template, e.g. for iterators:

```C++
template<typename IterT>
struct iterator_traits;
```

- by convention, traits always implemented as structs - those structs are called "traits classes"
- the way iterator_traits works is that for each typoe IterT, a typedef names iterator_category is declared in the sctruct iterator_traits<IterT> - this typedef identifies the iterator category of IterT
- to handle iterators that are pointers, a partial template specialization is used
- Sum up: to design and implement a traits class - a) identify information about types you'd like to make available, b) choose a name to identify that information (e.g., iterator_category), c) provide a template and set of specializations (e.g. iterator_traits) that contain the information for the types you want to support
- overloading a function - different parameter types for different overloads. When you call the function, compiler picks the best overload based on the passed arguments
- using trat class: a) create a set of overloaded "worker" functions or function templates that differ in a traits parameter, b) implem,ent each function in accord with the traits information passed, c) create a "master" function or function template that calls the worksers, apssing information provided by a trats class
- traits widely used in the standard library, e.g. iterator_traits, char_traits (information about character types), numeric_limits (information about numeric types, e.g. min and max values)

**TLDR:**
- **Trait classes make information about types available during compilation. They're implemented using templates and template specializations**
- **In conjunction with overloading, traits classes make it possible to perform compile-timne if..else tests on types**

### Item 48: Be aware of template metaprogramming

- template metaprogramming (TMP) - process of writing template-based C++ programs that execute during compilation
- when a TMP program finished, its output - pieces of C++ source code instantiated from templates - is then compiled as usual
- TMP has two great strenghts - 1) makes some things easy that otherwise would be hard or impossible, 2) template metaprograms can shift work from runtime to compile-time
- downside - compilation takes longer
- typeid-based approach less efficient than using traits - type testing at runtime and code doing runtime type testing must be in the executable
- fun fact - TMP is Turing-complete (using TMP you can declare variables, perform loops, write and call functions, etc. - looks differnt than regular C++ though)
- example library for TMP - Boost's MPL
- loops in TMP accomplished via recursion, precisely - recursive template instantiations
- TMP equivalent of "hello world" - factoria computation via recursive template instantiation

```C++
template<unsigned n>
struct Factorial {
  enum {value = n * Factorial<n - 1>::value};
};

template<>
struct Factorial<0> {
  enum {value = 1};
}
```

- what TMP can accomplish: a) ensuring demensional unit correctness, b) optimizing matrix operations (expression templates), c) generating custom design pattern implementations (policy-based design, basis for generative programming)
- TMP not for everyone - syntax unintuitive and tool support limited

**TLDR:**
- **Template metaprogramming can shift work from runtime to compile-timne, thus enabling earlier error detection and higher runtime performance**
- **TMP can be used to generate custom code based on combinations of policy choices, and it can also be used to avoid generationg code inappropriate for particular types**

****

## Customizing new and delete

### Item 49: Understand the behavior of the new-handler

- when `new` cant satisfy memory request, it throws an exception
- before throwing an exception, it calls (kinda) a new-handler - a client-specifiable error-handling function
- set_new_handler - sets the function new should call if it can't allocate the requested memory

```C++
void myFunction()
{
  ...
}

int main()
{
 std::set_new_handler(myFunction);
 ...
}

```
- when `new` unable to fulfill a memory request, it calls the new-handler function repeatedly until it can find enough memory
- a well-designed new-handler function must do on of the following: a) make more memory available, b) install a different new-handler, c) deinstall the new-handler, d) throw an exception, e) not return
- you can have each class provide its own versions of set_new_handler and operator new to handle memory differently for different classes
- "mixin-style" class - a base class that's designed to allow derived classes to inherit a single specific capability, e.g. the ability to set a class-specific new-handler
- curiously recurring template pattern (CRTP) - A class inheriting from a templatized base class that takes that class as a type parameter
- there is a no-throw version of new (new (std::nothrow) ClassName) but it's rarely needed

**TLDR:**
- **set_new_handler allows you to specify a function to be called when memory allocation requests cannot be satisfied.**
- **Nothrow new is of limited utility, because it applies only to memory allocation - associated constructor calls may still throw**

### Item 50: Understand when it makes sense to replace new and delete

- reason to replace 1: to detect usage errors
- underrun - writing prior to the beginning of an allocated block, overrun - writing beyond the end of an allocated block
- reason to replace 2: to improve efficiency: compiler-provided implementation are general-purpuse - not ideal for all use-cases, custom can improve speed (sometimes orders of magnitude) and memory requirement (up to 50% less)
- reason to replace 3: to collect user statistics
- many compuater architectures require that data of particular types be place in memory at particular kinds of addresses (or have better performance if this is satisfied), e.g. it's fastest to access doubles on the x86 architecture when ther are eight-byte aligned
- in most cases, you don't need to write your own new or delete - modern compilers can help with additional features
- Boost contains an example of a custom memory allocator - Pool - for large number of small objects

**TLDR - when to replace new and delete:**
- **to detect usage errors**
- **to collect statistics about the use of dynamically allocated memory**
- **to increase the speef of allocation and deallocation**
- **to reduce the space overhead of default memory management**
- **to compensate for suboptimal alignment in the default allocator**
- **to cluster related objects near one another**
- **to obtain unconventional behavior**

### Item 51: Adhere to convention when writing new and delete

- new implementation requires: right return value, calling the new-handling function when insufficient memory, and being prepared to cope with requests for no memory
- if you can supply memory, return pointer to it. If not, throw `bad_alloc`
- new-handling function called multiple times, after each failure (to e.g. try to free up some memory), only when pointer to new-handling function is unll does operator new throw
- C++ requires the operator new to return a legit pointer even when zero bytes are requested
- operator new contains an infinite loop - only way out is to provide memory or throw
- in C++ all freestanding objects have non-zero size
- delete implementation requires - you need to honor the C++'s guarantee that "it's always safe to delete the null pointer"

**TLDR:**
- **operator new should contain an infinite loop trying to allocate memory, should call the new-handler if it can't satisfy a memory request, and should handle requests for zero bytes. Class-specific versions should handle requests for larger blocks than expected**
- **operator delete should do nothing if passed a pointer that is null. Class-specific versions should handle blocks that are larger than expected**

### Item 52: Write placement delete if you write placement new

- with
```C++
Widget *pw = new Widget;
```
two function calls: operator new and default constructor
- if new succeeds but constructor fails, allocation needs to be undone, otherwise memory leak - responsibility for undoing on the C++ runtime system
- runtime system does that by calling delete, but must know which one
- no issue with normal signatures, problem when you declare non-normal new forms - ones that take additional parameters
- if operator new takes extra parameters (other than mandatory size_t), it's then known as a placement version of new
- particularily useful one - takes a pointer specifying where an object should be constructed (part of standard library, used e.g. by vector)
- if placement new - runtime system doesn't know how to undo it, doesn't know how the called version of new works - looks for a version of delete tkat takes the same number and tyypes of extra arguments, if doesnt find it - does nothing!
- delete with extra args = placement delete
- applying delete to a pointer never yields a call to a placement version of delete - so you must provide both versions of delete (placement and normal)
- because member functions hide functions with the same names in outer scopes, you need to be careful to avoid having class-specific news hide other news

**TLDR:**
- **When you write a placement version of new, be sure to write the corresponding placement version of delete. If you don't , your program may experience subtle, intermittent memory leaks**
- **When you declare placement versions of new and delete, be sure not to unintentionally hide the normal versions of those functions**

****

## Miscellany

### Item 53: Pay attention to compiler warnings

- sometimes different compiler messages seem to mean something different than what they actually mean - need to learn to understand
- best practice to compile warning-free
- if you really wanna ignore warning, make sure you understand exactly what it's saying

**TLDR**
- **Take compiler warning seriously, and strive to compile warning-free even at the maximum warning level**
- **Don't become dependent on compiler warnings, because different compilers warn about different things - porting to a new compiler may eliminate some warning messages**

### Item 54: Familiarize yourself with the standard library (including TR1)

- most new C++11 features in the form of STD additions
- major parts of STD by C++98:
  - Standard Template Library (STL) - containers, iterators, algorithms, function objects, various container and function object adapters
  - Iostreams - user-defined buffering, internalized IO, cin/cout/cerr/clog
  - Support for internationalization - including the abiity to have multiple active locales, types like wchar_t and wstring facilitate working with Unicode
  - Support for numeric processing - including templates for complex numbers and arrays of pure values
  - an exception hierarchy - including the base class `exception`, its derived classes `logic_error` and `runtime_error`, and various classes that inherit from those
  - C89's standard library - everything in the 1989 C standard library is also in C++
- should be familiar with all the above
- TR1 specifies 14 new components (all in std namespace):
  - smart pointers
  - std::function - possible to represent any callable entity whose signature is consistent with a target signature
  - std::bind
  - Hash tables - used to implement sets, multisets, maps, and multimaps (the unordered stuff)
  - Regular expressions - including ability to do regular expresion-based search and replace operations on strings, etc.
  - Tuples - nifty generalization of the pair template, can hold an arbitrary number
  - std::array
  - std::mem_fn - syntactically uniform way of adapting member function pointers (wrapper objects for pointers to members)
  - std::reference_wrapper - facility to make reference act a bit more like objects - among other things, this makes it possible to create containers that act as if they hold references
  - Random number generation - superior to rand
  - Mathematical special functions - including Laguerre polynomials, Bessel functions, complete elliptic integrals, and many more
  - C99 compatibility extensions - collection of functions and templates designed to bring many new C00 library features to C++
  - Type traits (TMP) - set of traits classes top provide compile-time information about tyoes
  - std::result_of (TMP) - a template to deduce the return types of function calls
- legacy code written with pre-TR1 constructs continues to be valid

**TLDR**
- **the primary standard C++ library functionality consists of the STL, iostream, and locales. The C89 standard library is also inlcuded**
- **TR1 adds support for smart pointers, generalized function pointers, hash-based containers, regular expressions, and 10 other components**

### Item 55: Familiarize yourself with boost

- Boost = collection of high-quality, open source, platform- and compiler-independent library
- both a community and libraries
- boost close relationship with C++ committee
- testing ground for capabilities that could be added to Standard C++
- process for accepting libraries based on public peer review
- exemples of libraries: Coversion (numeric_cast, lexical_cast), Boost Graph Library, Boost MPL library (metaprogramming)
- General categories of boost (not exhaustive):
  - String and text processing
  - Containers
  - Function objects and higher-order programming
  - Generic programming
  - Template metaprogramming
  - Math and numerics
  - Correctness and testing
  - Data structures
  - Inter-language support
  - Memory
  - Miscellaneous

**TLDR:**
- **Boost is a community and web site for the development of free, open source, peer-reviewed C++ libraries. Boost plays an influential role in C++ standarization**
- **Boost offers implementations of many TR1 components, but it also offers many other libraries**
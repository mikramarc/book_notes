# Effective C++

## Accustoming yourself to C++

### Item 1: View C++ as a federation of languages
- C
- O-O C++
- Template C++
- STL

**TLDR: Rules for effective programming in C++ depend on the part of C++ used.**

### Item 2: consts, enums, inlines > defines

- "Prefer the compiler to the preprocessor"
- name gets "removed" by preprocessor before it gets to the compiler -> hard to track down
- replace with constants
- smaller code - pre-processor bind substitution could result in multiple copies of a value
- constants for class - make it a member, to ensure one copy - make it static
- macros don't respect scope
- be aware of the "enum hack"

**TLDR:**
- **Prefer const or enums over defines**
- **For function-like macros prefer inline functions over defines**

### Item 3: Use const whenever possible

- sometimes it makes sense to return const value (e.g. operator overload)
- bitwise constness: method is const if it doesn't modify any of the object's data
- logical constness: method might modify some bits in the object, but only in ways that clients cannot detect
- use `mutable` to ensure logical constness if bitwise constness is broken
- avoid duplicating const and non-const methods, call const within non-const using casting instead

**TLDR:**
- **Declaring const helps the compiler detect usage errors**
- **const can be applied to objects of any scope, function params, return types, methods**
- **Compiler enforces bitwise constness, but you should program using logical constness**
- **Avoid code duplication by having non-const method version call the const version**

### Item 4: Initialize object before usage

- For non-member object of build-it types - manually initialize
- For almost everything else - constructor responsible for initialization everything in the object
- assignment is not initialization
- data members should be initialized before constructor body entered - use initialization list
- using initialization list more efficient than assignment
- use initialization list even when you want to default-construct a data member, specify nothing as an argument (might be an overkill)
- easiest to just *always* use initialization list
- could maybe omit initialization list if multiple constructors - use pseudo-initialization via assignment in shared method
- initialization order: base classes before derived, data members in order they are declared
- static objects - destroyed when the program exits (main finishes executing)
- translation unit - source file + it's include fies (source code giving rite to a single object file)
- local static objects are initialized when object's definition is first encountered during a call to that function
- non-const static objects = problem for multithreading

**TLDR:**
- **Manuall initialize objects of build-in type**
- **In a constructor, prefer use of initialization list**
- **list data in initialization list in the same order as declated in the class**
- **Replace non-local static objects with local static objects to prevent initialization order issues accross translation units**

****

## Constructors, Destructors, Assignment Operators

### Item 5: Know what functions C++ silently writes (and calls)

- if not explicitly declared, compiler will declare: copy constructor, copy assignment operator, desctructor
- if no constructor declared - also a default constructor
- all autogenerated will be public and inline
- C++ doesn;t provide a way to make a reference refer to a different object

**TLDR: Compiler may explicitly generate: default constructor, copy constructor, copy assignment operator, destructor.**

### Item 6: Disallow the use of compiler-generated functions you don't want

- you could forbid a copy of an object if e.g. you want each copy to be unique
- prevent autogeneration by declaring
- prevent usage by making private
- prevent usage by friends and members by NOT defining (link-time error)
- examples found in iostream, e.g. ios_base, basic_ios
- common convention - omit parameter names
- can move link-time error to compile time by making a uncopyable class and inherit from it
- there is an uncopyable version available in Boost (noncopyable)

**TLDR: to disallow methods autogeneration by compiler, declare the corresponding methods private and give them no implementations.**

### Item 7: Declare destructors virtual in polymorhic base classes

- relecant with base class pointers used
- factory function - returns a base class pointer to a newly-created derived class object
- problem - pointer to a derived class returned, deleted by a base class pointer, base class has a non-virtual destructor
- C++ specifies: if a derived class object deleted through a pointer to a base class without a virtual destructor -> undefined behaviour
- typically at runtime the derived part is never destroyed
- base part destroyed -> leaves a weird, partially destroyed object
- fix: give the base class a virtual destructor
- each class with virtual methods should almost certainly have a virtual destructor
- if no virtual methods = usually indicates the class not intended to be a base class -> virtual destructor usually a bad idea then
- if virtual methods - class carries a virtual table pointer (vptr) which points to virtual table (vtbl, array of funtion pointers).
- vptr will increase objects size, so don't add if not necessary
- STL container classes LACK virtual destructor - do NOT derive
- if you want a class without any pure virtual functions to be abstract - create a pure virtual destructor (need to provide a definition though)
- polymorphic base blass = base class designed to allow the manipulation of derived class types through base class interfaces
- virtual desctructors -> applies only to polymorphic base classes
- simplified version: declare virtual destructor if a class has a virtual method

**TLDR:**
- **Polymorphic base classes should declare a virtual destructor. A class has any virtual method -> it should have a virtual destructor**
- **Classes not desiged to be base or polymorphic should not have virtual desctructors**

### Item 8: Prevent destructors from emitting exceptions
- depending on a condition, multiple simultaneously active exceptions cause either program termination or undefined behaviour
- if need to run something in destructor that could throw exception, you can do two things: terminate the program (catch and sth::abort()) or swollow the exception (empty catch(), or make log entry in a catch())
- calling abort may forestall undefined behaviour, reasonable option if the program cannot continue to run after the error
- in general swallowing exception is a bad idea - it supressed important information, sometimes though it can prevent premature termination and undefined behaviour
- swallowing exception a viable option only if the program is able to reliable continue execution after an error occurs and is ignored
- better strategy - design the class interface so that its clients have an opportunity to react to problems that may arise, e.g. wrap a method that could throw exception in additional method with a flag inside
- if some operation may fail with exception and there may be a need to handle that exception -> the exception has to come from a non-destructor funtion

**TLDR:**
- **Destructors should NEVER emit exceptions. If function called in destructor may throw, catch and terminate or swallow**
- **If clients need to be able to react to exception, class should provide a regular (not a destructor) method that performs operation in question**

### Item 9: Never call virtual methods during construction and destruction

- Base class parts of derived class objects always constructed before derived class parts
- during base class construction virtual functions never go down into derived classes
- during base class construction of a derived class object, the type of the object IS that of the base class, and is treated like that
- one way to avoiding call of virtual function in constructor is making a function non-virtual with parameters and pass args from derived class constructors
- make the method above static - then no danger of accidentally using yet-uninitialized data members

**TLDR:**
**Never call virtual methods during construction and destruction - such call will never go to a more derived class than that of the currently executing constructor or destructor**

### Item 10: Have assignment operators always return a reference to *this

- assignment is right-associative (x = y = z = 15 <=> x = (y = (z = 15)))
- Follow this convention with custom assignment operators using return *this
- Applies also to +=, -=, *= etc.
- it's only a convention but followed by all the built-in types, STD types, etc.

**TLDR:**
**Make assignment operators return a reference to \*this**

### Item 11: Handle assignment to self in operator=

- aliasing = more than one way to refer to an object
- identity test - (`if(this == &rhs) return *this`)
- avoid having pointers to deleted objects
- making operator= exception-safe usually also self-assignment-safe
- ordering of statements (like deleting a pointer only after it's been used) can assure that
- alternative techinque for exception-safety - "copy and swap"

**TLDR:**
- **Use techniques like coparing addresses, careful statement ordering and copy-and-swap to assure operator= is well behaved**
- **Make sure that any funtion that operates on more than one object behaves correctly if two or more objects are the same**

### Item 12: Copy all parts of an object

- In a well-design system only two functions copy object - copy constructor and copy assignment operator (copying functions)
- Most compilers won't complain about if not all of data is copied by copying functions
- if you add a data member to your class, you need to make sure to update copying functions (also constructors)
- issues especially prone to happen with inheritance
- fix issues with inheritance by copying the base class parts - typically private so invoke corresponding base class copying funtioncs
- don't call one copying function in another
- use shared `init()` function to avoid code duplication is similar code in copy constructor and copy assignment operator

**TLDR:**
- **Copying functions should copy ALL of object's data members and ALL of its base class parts**
- **Don't call one of copying functions from another. Put common functionality in a third function and use it in both**

****

## Resource Management

### Item 13: Use objects to manage resources

- Other than memory, some other resource examples are: file descriptors, mutex locks, fonts and brushes in GUIs, database connections, network sockets
- "Manual" resource management is error-prone as code changes over time (people adding breaks, returns, exception throws etc.)
- automatically control resource management by putting resource inside objects
- smart pointers (like std::auto_ptr) automatically release memory in their destructors
- two critical aspects of using objects to manage resources: a) resources are aquired and immedaitely passed to resource-managing objects, b) resource-managing objects use destructors to ensure resource release
- using objects to manage resources ofter called RAII (Resource Acquisition Is Initialization) - common practice to acquire a resource and initialize a resource-managing object in the same statement
- sometimes acquired resources assigned to objects instead of initializing them
- example of RAII - `std::auto_ptr<SomeObject> pso(returnPtrToSomeObject())`
- reference-counting smart pointer (RCSP), e.g. shared_ptr - keeps track of how many objects point to particular resource
- RCSPs can't break cycles of references (two otherwise unused objects pointing to one another)
- don't use shared_ptr or auto_ptr for dynamically aloccated arrays in C++ (they use `delete` instead of `delete[]`). If you need this, look to Boost
(scoped_array, shared_array)
- bottom line - if you're releasing memory manually, you're doing something wrong
- returning of a raw pointer type - bad idea, invitation to a resource leak

**TLDR:**
- **To prevent resource leaks, use RAII objects that acquire resources in their constructors and release them in the destructors**
- **There are some commonly used RAII classes like std::shared_ptr, std::unique_ptr, etc.**

### Item 14: Carefully think about copying behavior in resource-managing classes

- another example of resource to be managed is locking and unlocking mutexes
- if RAII object copied, you should choose one of the following: prohibit copying (declare copying operations private), reference-count to underlying resource (you can use shared_ptr for that), copy the underlying resource (deep copy - should copy both object and the resource it wraps), transfer ownership of the underlying resource (e.g. auto_ptr)
- shared_ptr allows specification of a "deleter" - a function or function object to be called when the reference count goes to zero

**TLDR:**
- **Copying of RAII object means also copying managed resource, so copying behavior of the resources should determin the copying behavior of the RAII object**
- **Common copying behaviors - forbid copying, reference count, deep copy and ownership transfer**

### Item 15: Provide access to raw resources in resource-manging classes

 - sometimes APIs refer to resources (raw data) directly
 - you need to convert RAII object, two general ways: explicit conversion and explicit conversion
 - explicit conversion -> return (a copy of) raw pointer (e.g. inside a smart pointer), e.g. with a get() method for shared_ptr
 - explicit conversion - allow access to underlying data (e.g. by overloading and using -> and * operators)
- an alternative to explicit conversion using get() - implicit conversion function (`operator T() const { return val; }`)
- downside of implicit conversions - increased chance of error, e.g. when using copy assignment operator
- often explicit conversion is preferable -> minimizes chance of unintended conversions, not always the case - design decision
- functions returning raw resources in RAII classes aren't contrary to encapsulation - those classes' purpuse is to handle resrouces, not encapsulate

**TLDR:**
- **Each RAII class sould offer a way to access resource it manages - API's often require access to raw resouces**
- **Access may be through explicit or implicit conversion. In general, explicit conversions are safer, while implicit conversions more convenient to use**

### Item 16: Use same form in corresponding used of new and delete

- when you call `new`, two things happen - memory is allocated and one or more constructors for that memory are called
- when you call `delete` also two things happen - one or more destructors are called, then the memory is released
- memory for an array usually includes size of the array - ease for delete to know how many destructors to call
- if you delete on a pointer, you need to specify whether it's an array or not
- using incorrect `delete` leads to undefined behavior
- to avoid confusion regarding destruction, avoid typedeft for array types

**TLDR: If you use [] in a new expression, you must use [] in a corresponding delete expression, and vice versa.**

### Item 17: Store new-ed objects in smart pointers in standalone statements

- it's possible to leak resources even when using only RAII objects
- e.g. compiler can decide in what order arguments passed to a funtion are processed
- e.g. in a function call if arguments passed are function calls, one of them might throw exception while in another arg you're passing `new` to a smart pointer (`some_function(std::shared_ptr<someObj>(new someObj), other_function())`)
- to avoid that use a separate statement to pass resource to a RAII object, only then pass it - less leeway in reordering operations for the compiler

**TLDR: Store new objects in smart pointer in standalone statements**

****

## Designs and Declarations

### Item 18: Make interfaces easy to use correctly and difficult to use incorectly

 - if the client attempts to use interface incorrectly, it should not compile
 - can use structs/classes instead of basic types to enforce correct argument passing (e.g. `Hour(const Minute& m, const Hour& h)` instead of `Hour(int minute, int hour)`)
 - you can use static methods returning call to private constructor in a class to enforce specific values set (e.g. `static Month Jan() {return Month(1);}`)
 - you can also impose restrictions adding `const` (e.g. returning a const value from assignment operator)
 - interfaces should behave consistently
 - interface that requires client to remember something is prone to incorrect use
 - you can use a deleter in shared pointer to enforce specific behavior upon deleting
 - "cross-DLL problem" - object created by `new` in one DLL deleted in another DLL
 - shared pointer is biggerr than raw pointer, slower than raw pointer and uses auxiliary dynamic memory - but reduces client errors

**TLDR:**
- **Good interface = easy to use correctly, hard to use incorrectly**
- **Facilitate correct use with consistency in interfaces and behavioral compatibility with build-in types**
- **Ways to prevent errors include: creating new types, restricting operations on types, constraining object values, eliminating client resource management responsibilities**
- **shared_ptr supports custom deleters - prevents cross-DLL problem or can be used to automatically unlock mutexes**

### Item 19: Treat class design as type design

Consider:
- how should objects of your type be created/destroyed?
- how should object initialization differ from assignment?
- what does it mean for object to be passed by value?
- what are restrictions on allowed values for you class?
- does your new type fit into an inheritance graph?
- what kind of type conversions are allowed for you new class?
- what operators and functions make sense for the new type?
- what standard functions should be disallowed?
- who should have access to the members?
- what guarantees you new class offer with respect to performace, exception safety and resource usage ("undeclared interface")?
- how general is you new type?
- do you really need a new type?

**TLDR: Class design = type design**

 